<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Knockout.viewmodel : " />
    <script src="javascripts/prism.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/prism.css">

    <title>Knockout Viewmodel Plugin</title>
</head>

<body class="language-javascript">

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
            <a id="forkme_banner" href="https://github.com/coderenaissance/knockout.viewmodel">View on GitHub</a>

            <h1 id="project_title">Knockout Viewmodel Plugin</h1>
            <h2 id="project_tagline"></h2>

            <section id="downloads">
                <a class="zip_download_link" href="https://github.com/coderenaissance/knockout.viewmodel/zipball/master">Download this project as a .zip file</a>
                <a class="tar_download_link" href="https://github.com/coderenaissance/knockout.viewmodel/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
        <section id="main_content" class="inner">
            <h2>The Knockout Viewmodel Plugin (ko.viewmodel)</h2>

            <p>The knockout viewmodel plugin let's you create complex observable viewmodels easily and with more structure and control than ever before.</p>
            <p>Consider this simple example done with both the new viewmodel plugin and the old mapping plugin:</p>
            <div style="width: 45%; margin-right: 5%; float: left;">

                <strong>The New Viewmodel Plugin</strong><br />
                With the new viewmodel plugin all extensions needed for your viewmodel can be specified in your mapping using either full or partial paths. 
			This provides a natural orgainization to your code.
                <pre><code>
var model, mapping, viewmodel;

//Normally this JSON model 
//would be returned via ajax.
model = {
    users:[ 
        {
            firstName:"John", 
            lastName:"Doe",
            id:1,
            isDeleted: false
        },
        {
            firstName:"James", 
            lastName:"Smith",
            id:2,
            isDeleted: false
        }
    ]
};

mapping = {
  extend:{
    "{root}":function(root){
        root.Save = function(){
            $.ajax({
              url: 'ajax/test.html',
              data:ko.viewmodel.toModel(viewmodel),
              success: function(data) {
                ko.viewmodel.updateFromModel(data);
              }
            });
        };
    },
    "{root}.users":function(users){
        users.addNew = function(){
            users.push({
                firstName:"",
                lastName:"",
                id:null,
                isDeleted: false
            });
        };

        users.delete = function(user){
            user.isDeleted(true);
        };
    },  
    "{root}.users[i]":function(user){
        user().isNew = (!user.id === null);
    }
  },
  id:["{root}.users[i].id"]
};

viewmodel = ko.viewmodel.fromModel(model,mapping);

ko.applyBindings(viewmodel);
                </code></pre>
            </div>
            <div style="width: 45%; float: left;">
                <strong>The Old Mapping Plugin</strong><br />
                With the original mapping plugin there is no logical grouping which allows larger viewmodels to become disorganized and hard to follow.
			It also allows related code to easily become separated.
                <pre><code>
var model, mapping, viewmodel;

//Normally this JSON model 
//would be returned via ajax.
model = {
  users:[ 
     {
       firstName:"John", 
       lastName:"Doe",
       id:1,
       isDeleted:false
     },
     {
       firstName:"James", 
       lastName:"Smith",
       id:2,
       isDeleted:false
     }
    ]
};

mapping = {
    users:{
        key:function(user){
            return user.id();
        },
        create:function(options){
            var newUser = ko.mapping.fromJS(options.data);
            newUser.isNew = (newUser().id !== null);
        }
    }
};

viewmodel = ko.mapping.fromJS(model, mapping);

viewmodel.users.delete = function(user){
   user.isDeleted(true);
};

viewmodel.Save = function(){
    $.ajax({
        url: 'ajax/test.html',
        data:ko.mapping.toJs(viewmodel),
        success: function(data) {
            ko.viewmodel.fromJs(data);
        }
    });
};

viewmodel.users.addNew = function(){
    var newUser = {
        firstName:"",
        lastName:"",
        id:null,
        isDeleted: false
    };

    newUser = ko.mapping.fromJs(newUser);

    viewmodel.users.push(newUser);
};

ko.applyBindings(viewmodel);
                </code></pre>
            </div>
            <br style="clear: both" />
            <p>
                Note that the old mapping plugin only lets you specify part of your viewmodel creation (array items) in your mapping. 
			 In the viewmodel plugin example the addNew and delete functions are being added to the same object
			so they are naturally grouped together. 
            </p>

            <p>
                Of course the viewmodel plugin has even more benefits than this, but lets walk through everything
			from the beginning for those who may be newer to knockout.
            </p>

            <h3>Creating a simple viewmodel with ko.viewmodel</h3>

            <p>Creating a viewmodel from a model is simple.</p>

            <pre><code>var model, viewmodel;

//Normally this JSON model would be returned via ajax.
model = {
  users:[ 
        {firstName:"John", lastName:"Doe"},
        {firstName:"James", lastName:"Smith"}
    ]
};

viewmodel = ko.viewmodel.fromModel(model);
			</code></pre>

            <p>This code creates an viewModel with an observable array of users whose properties are observable.</p>

            <h3>Creating an extended viewmodel</h3>

            <p>Now lets say that you want to extend each object in the users array with an isDeleted flag. You would do this by specifying custom mapping options.</p>

            <pre><code>options:{ 
    extend:{
        "{root}.users[i]": function(user){
            user.isDeleted = ko.observable(false);
        }
    }
};

viewmodel = ko.viewmodel.fromModel(model,options));
</code></pre>

            <p>We've now extended each object in the users array with an isDeleted flag. </p>

            <p>If we also wanted to add a delete method to an array we would use the following options:</p>

            <pre><code>options:{ 
    extend:{
        "{root}.users[i]": function(user){
            user.isDeleted= ko.observable(false);
        },
        "{root}.users": function(users){
            users.Delete = function(user){
                user.isDeleted(true);
            }
        }
    }
};
</code></pre>

            <p>Note we've extending the observable array with the Delete function.
                <!--Here's a jsFiddle that shows the code bound to a view: <a href="http://jsfiddle.net/CodeRenaissance/ytjns/5/">http://jsfiddle.net/CodeRenaissance/ytjns/5/</a>-->
            </p>

            <h3>Getting an updated model from your viewmodel</h3>

            <p>At somepoint you'll need to get an updated model to send back up to the server. This can be done by calling toModel.</p>

            <pre><code>

model = ko.viewmodel.toModel(viewmodel);

</code></pre>

            <h3>Updating your viewmodel with new model data</h3>

            <p>If you need to update your viewmodel with more recent model data this can be done by calling updateFromModel.</p>

            <pre><code>

ko.viewmodel.updateFromModel(viewmodel, updatedModel);

</code></pre>
            <br />

            <h3>Custom Processing</h3>

            <p>Every property can have custom processing specified for it. Custom processing is specified for an item by it's path. </p>


            <h3>Path Types</h3>

            <p>Every full path starts with {root}. Items in an array are referred to as [i]. So a path of "{root}.users[i].firstName" would be used to specify custom processing for the firstName property of every object in the users array. That is its full path name, but it's not necessary to refer to every item by it's -full path name. There are three ways of referencing a path:</p>

            <ul>
                <li>Full Path Name - Matches only the specific path, e.g. "{root}.users[i].firstName".</li>
                <li>Parent Child Name - Matches the parent child combination specified. So "users[i].firstName" will only match the first name property on objects in the users array. Since this is an array we can also specify this as "[i].firstName" which would match every firstName property on an array child.</li>
                <li>Property Name - Matches every property with that name. So a partial path of "firstName" would match every firstName property in your model.</li>
            </ul>
            <h3>Processing Types</h3>

            <p>There four types of custom processing: map, append, exclude, and extend.</p>

            <ul>
                <li>map - the path and all of it's children are processed only as you specify</li>
                <li>append - the path and it's children are appended as is </li>
                <li>exclude - the path is excluded from processing</li>
                <li>extend - the path and it's children are processed normally but then extended/modified as specified</li>
                <li>id - used to flag an id on object withing an array... strictly for update purposes</li>
            </ul>
            <p>All processing types are exclusive.</p>

            <h3>The map processing option</h3>
            With the map processing option the path and all of it's children are processed only as you specify.
            <pre><code>
options:{ 
    extend:{
        "{root}.users[i]": function(user){
            user.isDeleted= ko.observable(false);
            return user;
        }
    }
};
</code></pre>
            In this case the users are passed through as is with the addition of an obeservable isDeleted flag. 
            <br />
            Note: 
            <ul>
                <li>Make sure to return something from your function, otherwise undefined will be returned as the result of map.</li>
                <li>The object passed into map is the unaltered object from your viewmodel or model (depending on if you are calling fromModel or toModel).</li>
            </ul>


            <h3>The append processing option</h3>
            With the append processing option the path and all of it's children are appended as is.
            <pre><code>
options:{ 
    append:["{root}.users[i]"]
};
</code></pre>
            In this case none of the users have been altered and are appended unchanged.

            <h3>The exclude processing option</h3>
            With the exclude processing option the path and it's children are excluded from processing and will not be included.
            <pre><code>
options:{ 
    exclude:["{root}.users[i].firstName"]
};
</code></pre>
            The firstName property is not included.

            When calling fromModel:
    <ul>
        <li>the path specified will not be wrapped in an observable.</li>
    </ul>
            When calling toModel:
    <ul>
        <li>if the path is for a computed value it will be unwrapped.</li>
        <li>if the path is for a non-observable value it will be included.</li>
    </ul>

            <h3>The extend processing option</h3>
            With the extend processing option the path and it's children are processed normally but then extended/modified as specified.
            <pre><code>
options:{ 
    extend:{
        "{root}.users[i]": function(user){
            user.isDeleted = ko.observable(false);
        }
    }
};
</code></pre>
            The value of the path is passed to the extend function after processing has been completed on the path and its children. Objects can be modified without being returned. 
Note: Whatever is returned from the extend function will be persisted and replace the default processing.

            <h3>The id processing option</h3>
            The id option allows you to flag what the id is on an object within an array of objects so that those objects can be updated. If an ID is not 
            specified then when updated data is loaded all old items will be removed from the array and new items added. If the original items were extended with an isDeleted flag or any other
            state management flags then that information would be lost. 
            <pre><code>
options:{ 
    id:["{root}.users[i].id"]
}
</code></pre>


            <h3>Can you trust that it works?</h3>
            There is a growing <a href="Tests.htm">suite of unit-tests</a> that say that you can. If you think you've found a bug please <a href="https://github.com/coderenaissance/knockout.viewmodel/issues?state=open">open an issue ticket </a>.
            Try to include code including a simplified model and failing tests so that very the issue and easily create unit tests for it.
        </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
        <footer class="inner">
            <p class="copyright">Knockout.viewmodel maintained by <a href="https://github.com/coderenaissance">coderenaissance</a></p>
            <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
        </footer>
    </div>



</body>
</html>
